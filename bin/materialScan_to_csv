#!/usr/bin/env python3

# SPDX-License-Identifier: LGPL-3.0-or-later
# Copyright (C) 2023 Chao Peng

'''
    A script to scan the materials thickness (X0 or Lambda) over eta and phi

    It uses dd4hep::rec::MaterialManager::placementsBetween to check the material layers, and then uses the detector
    alignment to transform world coordinates to local coordiantes, and then assigns the materials to a detector based
    on TGeoVolume::Contains

    To separate the scan result by detectors, each sub-detector under the worldvolume is scanned separately
'''

import os
import fnmatch
import argparse
import pandas as pd
import numpy as np
from collections import OrderedDict as odict

import dd4hep
import DDRec

pd.set_option('display.max_rows', 1000)
PROGRESS_STEP = 10


'''
    Re-implementation of MaterialScan::Print in DD4Hep::DDRec
    MaterialScan does not have a python interface and that function is relatively simple, so here it is
    desc: DD4hep::Detector
    start: 3D vector for start point
    end: 3D vector for end point
    epsilon: step size
'''
def material_scan(vol, start, end, epsilon, int_dets=None, thickness_corrector=None):
    mat_mng = DDRec.MaterialManager(vol)
    p0 = np.array(start)
    p1 = np.array(end)
    direction = (p1 - p0)/np.linalg.norm(p1 - p0)
    # print(p0, p1, direction)
    placements = mat_mng.placementsBetween(tuple(p0), tuple(p1), epsilon);

    # calculate material layer by layer
    int_x0 = 0
    int_lambda = 0
    path_length = 0.
    if thickness_corrector is not None:
        path_length = thickness_corrector.correct_path_length(direction, path_length)

    res = []
    for pv, l in placements:
        # print(pv, l)
        path_length += l
        pcurr = p0 + path_length*direction
        mat = pv.GetMedium().GetMaterial()
        radl = mat.GetRadLen()
        intl = mat.GetIntLen()
        x0 = l/radl
        lmd = l/intl
        res.append([
            # det_dict.get(det_id, 'Unknown'),
            mat.GetName(), mat.GetZ(), mat.GetA(), mat.GetDensity(),
            radl, intl, l, path_length,
            x0, lmd,
            pcurr[0], pcurr[1], pcurr[2],
            # local[0], local[1], local[2],
            ])
    cols = [
        'material', 'Z', 'A', 'density',
        'radl', 'intl', 'thickness', 'path_length',
        'X0', 'lambda',
        'x', 'y', 'z',
        # 'local_x', 'local_y', 'local_z'
        ]
    dft = pd.DataFrame(data=res, columns=cols)
    # print(dft.groupby('detector')['X0'].sum())
    return dft


'''
    A helper function to convert a string (<min>[:<max>[:<step>]]) to an array
'''
def args_array(arg, step=1, include_end=True):
    vals = [float(x.strip()) for x in arg.split(':')]
    # empty or only one value
    if len(vals) < 2:
        return np.array(vals)
    # has step input
    if len(vals) > 2:
        step = vals[2]
    # inclusion of the endpoint (max)
    if include_end:
        vals[1] += step
    return np.arange(vals[0], vals[1], step)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            prog='materialScan_to_csv',
            description = 'A python script to scan the materials by detector and save the results in CSV format.'
                        + '\n       ' # 7 spaces for "usage: "
                        + 'The scan is conducted with given ranges for both eta and phi.\n'
            )
    parser.add_argument(
            '-c', '--compact', dest='compact', required=True,
            help='Top-level xml file of the detector description.'
            )
    parser.add_argument(
            '-o', '--output', default='g4mat_scan_{value_type}.csv',
            help='Path of the output csv file. Support python formatting of args, e.g., g4mat_scan_{value_type}.csv.'
            )
    parser.add_argument(
            '--start-point', default='0,0,0',
            help='Start point of the scan, use the format \"x,y,z\", unit is cm.'
            )
    parser.add_argument(
            '--eta', default='-4.0:4.0:0.1',
            help='Eta range, in the format of \"<min>[:<max>[:<step>]]\".'
            )
    parser.add_argument(
            '--phi', default='0:30:1',
            help='Phi angle range, in the format of \"<min>[:<max>[:<step>]]\" (degree).'
            )
    parser.add_argument(
            '--mat-buffer-size', type=int, default=50,
            help='Material buffer size.'
            )
    args = parser.parse_args()

    if not os.path.exists(args.compact):
        print('Cannot find compact file {}'.format(args.compact))
        exit(-1)

    start_point = np.array([float(v.strip()) for v in args.start_point.split(',')])
    etas = args_array(args.eta)
    phis = args_array(args.phi)
    # sanity check
    if not len(phis):
        print('No phi values from the input {}, aborted!'.format(args.phi))
        exit(-1)
    mats_indices = odict()
    # a data buffer for the X0 values of (eta, material)
    data = np.zeros(shape=(len(etas)*len(phis), args.mat_buffer_size))

    doc = dd4hep.xml.DocumentHandler.parse(args.compact, 0)
